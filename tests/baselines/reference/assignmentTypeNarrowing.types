=== tests/cases/conformance/expressions/assignmentOperator/assignmentTypeNarrowing.ts ===
let x: string | number | boolean | RegExp;
>x : string | number | boolean | RegExp<string>

x = "";
>x = "" : ""
>x : string | number | boolean | RegExp<string>
>"" : ""

x; // string
>x : string

[x] = [true];
>[x] = [true] : [true]
>[x] : [string | number | boolean | RegExp<string>]
>x : string | number | boolean | RegExp<string>
>[true] : [true]
>true : true

x; // boolean
>x : true

[x = ""] = [1];
>[x = ""] = [1] : [number]
>[x = ""] : [string]
>x = "" : ""
>x : string | number | boolean | RegExp<string>
>"" : ""
>[1] : [number]
>1 : 1

x; // string | number
>x : string | number

({x} = {x: true});
>({x} = {x: true}) : { x: true; }
>{x} = {x: true} : { x: true; }
>{x} : { x: string | number | boolean | RegExp<string>; }
>x : string | number | boolean | RegExp<string>
>{x: true} : { x: true; }
>x : true
>true : true

x; // boolean
>x : true

({y: x} = {y: 1});
>({y: x} = {y: 1}) : { y: number; }
>{y: x} = {y: 1} : { y: number; }
>{y: x} : { y: string | number | boolean | RegExp<string>; }
>y : string | number | boolean | RegExp<string>
>x : string | number | boolean | RegExp<string>
>{y: 1} : { y: number; }
>y : number
>1 : 1

x; // number
>x : number

({x = ""} = {x: true});
>({x = ""} = {x: true}) : { x?: true; }
>{x = ""} = {x: true} : { x?: true; }
>{x = ""} : { x?: string | number | boolean | RegExp<string>; }
>x : string | number | boolean | RegExp<string>
>"" : ""
>{x: true} : { x?: true; }
>x : true
>true : true

x; // string | boolean
>x : string | true

({y: x = /a/} = {y: 1});
>({y: x = /a/} = {y: 1}) : { y?: number; }
>{y: x = /a/} = {y: 1} : { y?: number; }
>{y: x = /a/} : { y?: RegExp</a/>; }
>y : RegExp</a/>
>x = /a/ : RegExp</a/>
>x : string | number | boolean | RegExp<string>
>/a/ : RegExp</a/>
>{y: 1} : { y?: number; }
>y : number
>1 : 1

x; // number | RegExp
>x : number | RegExp<string>

let a: string[];
>a : string[]

for (x of a) {
>x : string | number | boolean | RegExp<string>
>a : string[]

    x; // string
>x : string
}

// Repro from #26405

type AOrArrA<T> = T | T[];
>AOrArrA : AOrArrA<T>

const arr: AOrArrA<{x?: "ok"}> = [{ x: "ok" }]; // weak type
>arr : AOrArrA<{ x?: "ok"; }>
>x : "ok"
>[{ x: "ok" }] : { x: "ok"; }[]
>{ x: "ok" } : { x: "ok"; }
>x : "ok"
>"ok" : "ok"

arr.push({ x: "ok" });
>arr.push({ x: "ok" }) : number
>arr.push : (...items: { x?: "ok"; }[]) => number
>arr : { x?: "ok"; }[]
>push : (...items: { x?: "ok"; }[]) => number
>{ x: "ok" } : { x: "ok"; }
>x : "ok"
>"ok" : "ok"

