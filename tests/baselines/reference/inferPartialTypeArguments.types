=== tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArguments.tsx ===
declare module JSX {
    interface Element {}
}
declare namespace React {
>React : typeof React

    export function createElement(x: any, p: any, ...children: any[]): JSX.Element;
>createElement : (x: any, p: any, ...children: any[]) => JSX.Element
>x : any
>p : any
>children : any[]
>JSX : any
}
 class Foo<T, U> {
>Foo : Foo<T, U>

    constructor(public prop1: T, public prop2: U) {}
>prop1 : T
>prop2 : U
}
 function foo<T, U>(x: T, y: U): [T, U] { return [x, y]; }
>foo : <T, U>(x: T, y: U) => [T, U]
>x : T
>y : U
>[x, y] : [T, U]
>x : T
>y : U

 function tag<T, U>(x: TemplateStringsArray, ...args: (T | U)[]) { return args; }
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>x : TemplateStringsArray
>args : (T | U)[]
>args : (T | U)[]

 interface ComponentProps<T, U> {
    x: T;
>x : T

    y: U;
>y : U

    cb(props: this): void;
>cb : (props: this) => void
>props : this
}
 function Component<T, U>(x: ComponentProps<T, U>) {
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>x : ComponentProps<T, U>

    return <h></h>;
><h></h> : JSX.Element
>h : any
>h : any
}

const instance1 = new Foo<number, *>(0, "");
>instance1 : Foo<number, string>
>new Foo<number, *>(0, "") : Foo<number, string>
>Foo : typeof Foo
>0 : 0
>"" : ""

const result1 = foo<number, *>(0, "");
>result1 : [number, string]
>foo<number, *>(0, "") : [number, string]
>foo : <T, U>(x: T, y: U) => [T, U]
>0 : 0
>"" : ""

// const tagged1 = tag<number, *>`tags ${12} ${""}`; // Because of how union inference works, this won't actually work
const jsx1 = <Component<number, *> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx1 : JSX.Element
><Component<number, *> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

const instance2 = new Foo<*, string>(0, "");
>instance2 : Foo<number, string>
>new Foo<*, string>(0, "") : Foo<number, string>
>Foo : typeof Foo
>0 : 0
>"" : ""

const result2 = foo<*, string>(0, "");
>result2 : [number, string]
>foo<*, string>(0, "") : [number, string]
>foo : <T, U>(x: T, y: U) => [T, U]
>0 : 0
>"" : ""

const tagged2 = tag<*, string>`tags ${12} ${""}`; // this will, though! Just because the `*` comes first!
>tagged2 : (string | number)[]
>tag<*, string>`tags ${12} ${""}` : (string | number)[]
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx2 = <Component<*, string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx2 : JSX.Element
><Component<*, string> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

const instance3 = new Foo<*, *>(0, "");
>instance3 : Foo<number, string>
>new Foo<*, *>(0, "") : Foo<number, string>
>Foo : typeof Foo
>0 : 0
>"" : ""

const result3 = foo<*, *>(0, "");
>result3 : [number, string]
>foo<*, *>(0, "") : [number, string]
>foo : <T, U>(x: T, y: U) => [T, U]
>0 : 0
>"" : ""

const tagged3 = tag<*, *>`tags ${12} ${""}`;
>tagged3 : {}[]
>tag<*, *>`tags ${12} ${""}` : {}[]
>tag : <T, U>(x: TemplateStringsArray, ...args: (T | U)[]) => (T | U)[]
>`tags ${12} ${""}` : string
>12 : 12
>"" : ""

const jsx3 = <Component<*, *> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} />;
>jsx3 : JSX.Element
><Component<*, *> x={12} y="" cb={props => void (props.x.toFixed() + props.y.toUpperCase())} /> : JSX.Element
>Component : <T, U>(x: ComponentProps<T, U>) => JSX.Element
>x : number
>12 : 12
>y : string
>cb : (props: ComponentProps<number, string>) => any
>props => void (props.x.toFixed() + props.y.toUpperCase()) : (props: ComponentProps<number, string>) => any
>props : ComponentProps<number, string>
>void (props.x.toFixed() + props.y.toUpperCase()) : undefined
>(props.x.toFixed() + props.y.toUpperCase()) : string
>props.x.toFixed() + props.y.toUpperCase() : string
>props.x.toFixed() : string
>props.x.toFixed : (fractionDigits?: number) => string
>props.x : number
>props : ComponentProps<number, string>
>x : number
>toFixed : (fractionDigits?: number) => string
>props.y.toUpperCase() : string
>props.y.toUpperCase : () => string
>props.y : string
>props : ComponentProps<number, string>
>y : string
>toUpperCase : () => string

declare function stillDefaultsIfNoInference<X, A = string, B = number, C = boolean>(arg: { a?: A, b?: B, c?: C, x?: X}): { a: A, b: B, c: C, x: X };
>stillDefaultsIfNoInference : <X, A = string, B = number, C = boolean>(arg: { a?: A; b?: B; c?: C; x?: X; }) => { a: A; b: B; c: C; x: X; }
>arg : { a?: A; b?: B; c?: C; x?: X; }
>a : A
>b : B
>c : C
>x : X
>a : A
>b : B
>c : C
>x : X

const result4 = stillDefaultsIfNoInference<*, *, *, object> ({ b: "test" }); // expect result1 type is {a: string, b: string, c: object, x: {}
>result4 : { a: string; b: string; c: object; x: {}; }
>stillDefaultsIfNoInference<*, *, *, object> ({ b: "test" }) : { a: string; b: string; c: object; x: {}; }
>stillDefaultsIfNoInference : <X, A = string, B = number, C = boolean>(arg: { a?: A; b?: B; c?: C; x?: X; }) => { a: A; b: B; c: C; x: X; }
>{ b: "test" } : { b: string; }
>b : string
>"test" : "test"

class Foo2<A extends {x: string} = {x: string, y: number}, B = number> {
>Foo2 : Foo2<A, B>
>x : string
>x : string
>y : number

    constructor(public a?: A, public b?: B) {}
>a : A
>b : B
}
const x = new Foo2<*, string>();
>x : Foo2<{ x: string; y: number; }, string>
>new Foo2<*, string>() : Foo2<{ x: string; y: number; }, string>
>Foo2 : typeof Foo2

x.a.x;
>x.a.x : string
>x.a : { x: string; y: number; }
>x : Foo2<{ x: string; y: number; }, string>
>a : { x: string; y: number; }
>x : string

x.a.y;
>x.a.y : number
>x.a : { x: string; y: number; }
>x : Foo2<{ x: string; y: number; }, string>
>a : { x: string; y: number; }
>y : number

x.b;
>x.b : string
>x : Foo2<{ x: string; y: number; }, string>
>b : string

type Box<T> = { value: T };
>Box : Box<T>
>value : T

type HasBoxedNumber = Box<number>;
>HasBoxedNumber : Box<number>

declare function extractBox<T extends Box<S>, S>(arg: T): S;
>extractBox : <T extends Box<S>, S>(arg: T) => S
>arg : T

declare const hbn: HasBoxedNumber;
>hbn : Box<number>

extractBox<HasBoxedNumber, *>(hbn).toFixed();
>extractBox<HasBoxedNumber, *>(hbn).toFixed() : string
>extractBox<HasBoxedNumber, *>(hbn).toFixed : (fractionDigits?: number) => string
>extractBox<HasBoxedNumber, *>(hbn) : number
>extractBox : <T extends Box<S>, S>(arg: T) => S
>hbn : Box<number>
>toFixed : (fractionDigits?: number) => string

