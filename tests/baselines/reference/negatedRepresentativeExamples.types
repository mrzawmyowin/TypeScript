=== tests/cases/conformance/types/negated/negatedRepresentativeExamples.ts ===
// https://github.com/Microsoft/TypeScript/issues/7993

declare function ignore<T extends not (object & Promise<any>)>(value: T): void;
>ignore : <T extends not object | not Promise<any>>(value: T) => void
>value : T

declare function readFileAsync(): Promise<string>;
>readFileAsync : () => Promise<string>

declare function readFileSync(): string;
>readFileSync : () => string

ignore(readFileSync());     // OK
>ignore(readFileSync()) : void
>ignore : <T extends not object | not Promise<any>>(value: T) => void
>readFileSync() : string
>readFileSync : () => string

ignore(readFileAsync());    // Should error
>ignore(readFileAsync()) : any
>ignore : <T extends not object | not Promise<any>>(value: T) => void
>readFileAsync() : Promise<string>
>readFileAsync : () => Promise<string>

declare function map<T, U extends not void>(values: T[], map: (value: T) => U) : U[]; // validate map callback doesn't return void
>map : <T, U extends not void>(values: T[], map: (value: T) => U) => U[]
>values : T[]
>map : (value: T) => U
>value : T

function foo() {}
>foo : () => void

map([1, 2, 3], n => n + 1); // OK
>map([1, 2, 3], n => n + 1) : number[]
>map : <T, U extends not void>(values: T[], map: (value: T) => U) => U[]
>[1, 2, 3] : number[]
>1 : 1
>2 : 2
>3 : 3
>n => n + 1 : (n: number) => number
>n : number
>n + 1 : number
>n : number
>1 : 1

map([1, 2, 3], foo);        // Should error
>map([1, 2, 3], foo) : any
>map : <T, U extends not void>(values: T[], map: (value: T) => U) => U[]
>[1, 2, 3] : number[]
>1 : 1
>2 : 2
>3 : 3
>foo : () => void

function asValid<T extends not null>(value: T, isValid: (value: T) => boolean) : T | null {
>asValid : <T extends not null>(value: T, isValid: (value: T) => boolean) => T | null
>null : null
>value : T
>isValid : (value: T) => boolean
>value : T
>null : null

    return isValid(value) ? value : null;
>isValid(value) ? value : null : T | null
>isValid(value) : boolean
>isValid : (value: T) => boolean
>value : T
>value : T
>null : null
}

declare const x: number;
>x : number

declare const y: number | null;
>y : number | null
>null : null

asValid(x, n => n >= 0);    // OK
>asValid(x, n => n >= 0) : number | null
>asValid : <T extends not null>(value: T, isValid: (value: T) => boolean) => T | null
>x : number
>n => n >= 0 : (n: number) => boolean
>n : number
>n >= 0 : boolean
>n : number
>0 : 0

asValid(y, n => n >= 0);    // Should error
>asValid(y, n => n >= 0) : any
>asValid : <T extends not null>(value: T, isValid: (value: T) => boolean) => T | null
>y : number | null
>n => n >= 0 : (n: any) => boolean
>n : any
>n >= 0 : boolean
>n : any
>0 : 0

function tryAt<T extends not undefined>(values: T[], index: number): T | undefined {
>tryAt : <T extends not undefined>(values: T[], index: number) => T | undefined
>values : T[]
>index : number

    return values[index];
>values[index] : T
>values : T[]
>index : number
}

declare const a: number[];
>a : number[]

declare const b: (number | undefined)[];
>b : (number | undefined)[]

tryAt(a, 0);    // OK
>tryAt(a, 0) : number | undefined
>tryAt : <T extends not undefined>(values: T[], index: number) => T | undefined
>a : number[]
>0 : 0

tryAt(b, 0);    // Should error
>tryAt(b, 0) : any
>tryAt : <T extends not undefined>(values: T[], index: number) => T | undefined
>b : (number | undefined)[]
>0 : 0

